// Utilities
import PaletteCore from "@/utils/palettes/palette-core";
import PaletteCustom from "@/utils/palettes/palette-custom";
import ThemeColor from "@/utils/theme/theme-color";
import { defineStore } from "pinia";
import { useTheme } from "vuetify";
import { Variant, VariantDetails } from "@/utils/dynamiccolor/variant.js";
import { VariantScheme } from "@/utils/scheme/variant-scheme";
import { argbFromHex, hexFromArgb, TonalPalette } from "@material/material-color-utilities";
import { computed, ref } from "vue";

class MaterialTheme {
  /**
   * The default source color.
   *
   * @value {string} The hex value of the default color.
   */
  static get defaultColor() {
    return "#39548d";
  }

  /**
   * Returns the default variant for the material theme.
   *
   * @value {number} The variant value representing the RAINBOW theme.
   */
  static get defaultVariant() {
    return Variant.RAINBOW;
  }

  /**
   * Returns the default contrast for the material theme.
   *
   * @value {number} The default contrast value.
   */
  static get defaultContrast() {
    return 0.0;
  }

  /**
   * Returns the default color scheme for the material theme.
   *
   * This scheme is created using the default source color and the RAINBOW variant.
   *
   * @value {VariantScheme} The default VariantScheme object instance.
   */
  static get defaultScheme() {
    const scheme = VariantScheme.createScheme(0xff39548d, Variant.RAINBOW);
    return scheme;
  }

  /**
   * Updates the theme color of a theme item by getting the tone value of the theme item
   * from the given argb color and sets the hex and argb values of the theme item accordingly.
   *
   * Note: The `themeItem` object is mutated in-place and because of reactivity, it affects the store's `currentScheme`.
   *
   * @param {ThemeColor} themeItem - The theme item to be updated.
   * @param {number} argb - The `PaletteCore` or `PaletteCustom` argb color to be used to update the `themeItem` color.
   *
   * @returns {ThemeColor} The updated theme item.
   */
  static updateThemeColor(themeItem, argb) {
    console.log("MaterialTheme ::: updateThemeColor");
    // Create TonalPalette from the scheme palette's argb color
    const tp = TonalPalette.fromInt(argb);

    // Get the ARGB color from the TonalPalette for the tone of the `themeItem`.
    // NOTE: The `themeItem.tone` value may have been changed by the user in the UI.
    //   [*] Use the initial tone value instead of the current tone value.
    themeItem.tone = themeItem.initialTone;
    let itemArgb = tp.tone(themeItem.tone);
    console.log(" - itemArgb: ", itemArgb);

    let itemHex = hexFromArgb(itemArgb);
    console.log(" - itemHex: ", itemHex);
    themeItem.hex = itemHex;

    return themeItem;
  }

  /**
   * Updates the Vuetify theme definition colors with the given theme colors for the given theme type (`isDark`).
   *
   * @param {Object} themeDef - The theme definition object to be updated.
   * @param {Array<ThemeColor>} themeColors - The theme colors to be used for the theme definition.
   * @param {boolean} isDark - True if the theme is a dark theme, false otherwise.
   * @param {boolean} includeOnColors - True if the theme colors should include the on-colors, false otherwise.
   */
  static updateHctThemeInstance(themeDef, themeColors, includeOnColors) {
    console.log("MaterialTheme ::: updateHctThemeInstance");

    console.log(" - themeDef: ", themeDef);
    console.log(" - themeColors: ", themeColors);
    console.log(" - is dark: ", themeDef.dark);
    console.log(" - includeOnColors: ", includeOnColors);

    themeColors.forEach((entry) => {
      const name = entry.name;
      if (name === "surfaceVariant") {
        let tp = TonalPalette.fromInt(entry.argb);
        // TODO: Check if the surface-variant tone value is the same for each Scheme Variant generated by Material Utilities.
        // Dark and light theme have different surface-variant tone values.
        let surfaceVariantArgb = themeDef.dark ? tp.tone(60) : tp.tone(30);
        // surfaceVariant palette's hex is used for the `surface-light` and `on-surface-variant` styles.
        // The theme's `surface-variant` style is the surfaceVariant palette's hex at tone 60 (dark theme) or 30 (light theme).
        themeDef.colors["surface-light"] = entry.hex;
        themeDef.colors["surface-variant"] = hexFromArgb(surfaceVariantArgb);
        themeDef.colors["on-surface-variant"] = entry.hex;
      } else if (name === "background" || name === "surface") {
        themeDef.colors[name] = entry.hex;
      } else {
        themeDef.colors[name] = entry.hex;
        // Add the on color for the current entry, if enabled.
        const onName = "on-" + name;
        console.log(" - color has on color: ", onName, onName in themeDef.colors);
        if (includeOnColors) {
          themeDef.colors[onName] = entry.onHex;
        } else if (onName in themeDef.colors) {
          // Delete the `on` color for the current entry so that Vuetify generates default on-colors.
          delete themeDef.colors[onName];
        }
      }
    });
    console.log(" - themeDef.colors: ", themeDef.colors);
  }

  /**
   * represents a list of random/favorite hex colors.
   * These can be used as the source color for the store scheme.
   *
   * @value {string[]} A list of random/favorite hex colors.
   */
  static get favoriteColors() {
    return [
      "#F9C3D3",
      "#F4AB82",
      "#BEC4b2",
      "#B4BCB3",
      "#AE73A0",
      "#828275",
      "#6A6B63",
      "#6584A6",
      "#6A6255",
      "#3C444D",
      "#494F60",
      "#434943",
      "#4d491d",
      "#3B503C",
      "#2A4457",
      "#545B42",
      "#45708E",
      "#39548d",
      "#0D4F48",
      "#96598D",
      "#890D3C",
      "#01638d",
      "#8bb29c",
      "#CB4994",
      "#A7637A"
    ];
  }
}

const DARK_THEME_NAME = "hct-dark";
const LIGHT_THEME_NAME = "hct-light";

/**
 * Private store for the material theme.
 */
const useMaterialStore = defineStore("materialStore", () => {
  /**
   * STORE STATE (PROPERTIES)
   */

  /**
   * The Material theme store.
   */
  const themeInstance = ref(useTheme());

  /**
   * GETTERS (COMPUTED METHODS)
   */

  /**
   * Returns the material dark theme (hct-dark).
   *
   * @returns {InternalThemeDefinition} The material dark theme.
   */
  const hctDark = computed(() => {
    console.log("ThemeStore ::: hctDark");
    return themeInstance.themes[DARK_THEME_NAME];
  });

  /**
   * Returns the material light theme (hct-light).
   *
   * @returns {InternalThemeDefinition} The material light theme.
   */
  const hctLight = computed(() => {
    console.log("MaterialStore ::: hctLight");
    return themeInstance.themes[LIGHT_THEME_NAME];
  });

  /**
   * Returns the themes object, which is a map of theme names to their definitions.
   *
   * This is a reactive getter and will return the updated themes object
   * when the theme instance is updated.
   *
   * @returns {Record<string, InternalThemeDefinition>} The themes object.
   */
  const themes = computed(() => {
    console.log("MaterialStore ::: themes");
    // console.log(" - themes: ", themeInstance.themes);
    return themeInstance.value.themes;
  });

  /**
   * ACTIONS METHODS
   */

  /**
   * Updates the "hct-dark" and "hct-light theme styles.
   *
   * This method takes in arrays of color definitions for both dark and light themes,
   * and updates the internal HCT theme styles with these new color definitions.
   *
   * @param {Array<ThemeColor>} dark - An array of color definitions for the dark theme.
   * @param {Array<ThemeColor>} light - An array of color definitions for the light theme.
   */
  function updateHctThemeStyles(dark, light, includeOnColors) {
    console.log("MaterialStore ::: updateHctThemeStyles");
    console.log(" - include on colors: ", includeOnColors);

    let hctLight = themeInstance.value.themes[LIGHT_THEME_NAME];
    let hctDark = themeInstance.value.themes[DARK_THEME_NAME];

    [hctLight, hctDark].forEach((themeDef) => {
      // TODO: Look into deleting the `primary-darken-1` and `secondary-darken-1` colors from the hct theme definition.
      // let pDarken1 = "primary-darken-1";
      // let sDarken1 = "secondary-darken-1";
      // if (pDarken1 in themeDef.colors) {
      //   delete themeDef.colors[pDarken1];
      // }
      // if (sDarken1 in themeDef.colors) {
      //   delete themeDef.colors[sDarken1];
      // }

      const themeColors = themeDef.dark ? dark : light;

      themeColors.forEach((entry) => {
        const name = entry.name;
        if (name === "surfaceVariant") {
          let tp = TonalPalette.fromInt(entry.argb);
          // TODO: Check if the surface-variant tone value is the same for each Scheme Variant generated by Material Utilities.
          // Dark and light theme have different surface-variant tone values.
          let surfaceVariantArgb = themeDef.dark ? tp.tone(60) : tp.tone(30);
          // surfaceVariant palette's hex is used for the `surface-light` and `on-surface-variant` styles.
          // The theme's `surface-variant` style is the surfaceVariant palette's hex at tone 60 (dark theme) or 30 (light theme).
          themeDef.colors["surface-light"] = entry.hex;
          themeDef.colors["surface-variant"] = hexFromArgb(surfaceVariantArgb);
          themeDef.colors["on-surface-variant"] = entry.hex;
        } else if (name === "background" || name === "surface") {
          themeDef.colors[name] = entry.hex;
        } else {
          themeDef.colors[name] = entry.hex;
          // Add the on color for the current entry, if enabled.
          const onName = "on-" + name;
          // console.log(" - color has on color: ", onName, onName in themeDef.colors);
          if (includeOnColors) {
            themeDef.colors[onName] = entry.onHex;
          } else if (onName in themeDef.colors) {
            // Delete the `on` color for the current entry so that Vuetify generates default on-colors.
            delete themeDef.colors[onName];
          }
        }
      });
      console.log(" - themeDef.colors: ", themeDef.colors);
    });
  }
  // Pinia return object
  return { hctDark, hctLight, themes, updateHctThemeStyles };
});

// const defaultColor = "#39548d";
// const defaultVariant = Variant.RAINBOW;
// const defaultScheme = VariantScheme.createScheme(0xff39548d, Variant.RAINBOW);

// Pinia: https://pinia.esm.dev/
export const useMaterialThemeStore = defineStore(
  "materialTheme",
  () => {
    //[-]============================
    //[-] STATE (PROPERTIES)
    //[-]============================

    /**
     * The Material store.
     *
     * Should not be accessed from outside the store and is therefor not exported.
     */
    const materialStore = ref(useMaterialStore());

    /**
     * The current Scheme Variant. Used to generate the scheme.
     *
     * @type {ref<Variant>}
     * @see {@link Variant}
     */
    const currentVariant = ref(MaterialTheme.defaultVariant);

    /**
     * The current Scheme contrast.
     *
     * Valid values are:
     * - -1.0 (low contrast)
     * - 0.0 (default contrast)
     * - 0.5 (medium contrast)
     * - 1.0 (high contrast)
     *
     * The default value is 0.0 (default contrast).
     *
     * @value {ref<number>} The default contrast value.
     */
    const currentContrast = ref(MaterialTheme.defaultContrast);

    /**
     * The current source color - in hex format - from which the scheme is generated.
     * @type {ref<string>}
     */
    const sourceColor = ref(MaterialTheme.defaultColor);

    /**
     * The current color scheme, generated from the source color.
     * @type {VariantScheme}
     * @see {@link VariantScheme}
     */
    const currentScheme = ref(MaterialTheme.defaultScheme);

    /**
     * Whether or not to show the image cards.
     *
     * This is a UI state property.
     *
     * @type {ref<boolean>}
     */
    const showImageCards = ref(true);

    /**
     * Whether or not to show the variant info.
     *
     * This is a UI state property.
     *
     * @type {ref<boolean>}
     */
    const showVariantInfo = ref(true);

    /**
     * Whether or not to show the palette detail cards.
     *
     * This is a UI state property.
     *
     * @type {ref<boolean>}
     */
    const showPaletteCards = ref(true);

    /**
     * Whether or not to expand the theme cards.
     *
     * This is a UI state property.
     * The toggle state is a property of the `ThemeColor` class.
     *
     * @type {ref<boolean>}
     */
    const expandThemeCards = ref(false);

    /**
     * Whether or not to show the dark theme card.
     *
     * This is a UI state property.
     *
     * @type {ref<boolean>}
     */
    const showDarkThemeCard = ref(true);

    /**
     * Whether or not to show the light theme card.
     *
     * This is a UI state property.
     *
     * @type {ref<boolean>}
     */
    const showLightThemeCard = ref(true);

    /**
     * Whether or not to include "on-" colors in the generated theme.
     *
     * When set to false, the final theme will not include on-colors and
     * Vuetify will then resort to its default colors,
     * which are black for the light theme, and white for the dark theme.
     *
     * @type {ref<boolean>}
     */
    const includeOnColors = ref(true);

    //[-]============================
    //[-] GETTERS (COMPUTED METHODS)
    //[-]============================

    /**
     * Returns a list with scheme variant details, including their descriptions.
     *
     * @property {string} title - The title/name of the scheme variant, used for display.
     * @property {number} value - One of the Variant static constants. e.g Variant.RAINBOW
     * @property {string} desc - The description of the scheme variant.
     *
     * @returns {Array<VariantDetails>} A list of scheme variants.
     *
     * @see {@link VariantDetails}
     */
    const schemeVariants = computed(() => {
      return VariantDetails.info;
    });

    /**
     * A list of random/favorite hex colors.
     *
     * @returns {Array<string>} A list of random/favorite hex colors.
     */
    const favoriteColors = computed(() => {
      return MaterialTheme.favoriteColors;
    });

    //[-]============================
    //[-] ACTIONS (METHODS)
    //[-]============================

    /**
     * Toggles the expanded state of all theme cards to the value of `expandThemeCards`.
     *
     * This is a convenience method that can be used to quickly toggle the expanded state
     * of all theme cards from the UI.
     */
    function toggleAllThemeCards() {
      console.log("MaterialThemeStore ::: toggleAllThemeCards");
      currentScheme.value.light.forEach((tcolor) => (tcolor.toggle = expandThemeCards.value));
      currentScheme.value.dark.forEach((tcolor) => (tcolor.toggle = expandThemeCards.value));
    }

    /**
     * Sets the current variant to the given value and creates a new scheme for that variant.
     *
     * @param {Variant} variant - The new variant value to set in the material theme store.
     */
    function setCurrentVariant(variant) {
      console.log("MaterialThemeStore ::: setCurrentVariant");
      currentVariant.value = variant;
      createSchemeForHex(sourceColor.value);
    }

    /**
     * Updates the hct-dark and hct-light theme styles with the colors from the current scheme.
     *
     * Calls `updateHctThemeStyles` on the `materialStore` to update the styles of
     * the Vuetify `hct-dark` and `hct-light` themes.
     */
    function updateThemeStyles() {
      console.log("MaterialThemeStore ::: updateThemeStyles");
      // TODO: Look into only updating the modified hct-dark and hct-light theme styles,
      //   [x] instead of updating all hct theme styles.
      let scheme = currentScheme.value;
      // Update the hct-dark and hct-light theme styles.
      materialStore.value.updateHctThemeStyles(scheme.dark, scheme.light, includeOnColors.value);
    }

    /**
     * Updates the `light` and `dark` theme colors for the given palette item in the current scheme (`materialThemeStore.currentScheme`).
     *
     * - If the palette item name is `neutral`, it will update the light and dark `background` and `surface` theme colors.
     * - If the palette item name is `neutralVariant`, it will update the light and dark `surfaceVariant` theme color.
     *
     * @example
     * const paletteItem = new PaletteColor("Primary","primary","#ff0000");
     * materialThemeStore.updateThemeForPalette(paletteItem);
     *
     * @param {PaletteCore|PaletteCustom} palette - The modified palette item, containing the new hex color and the name of the color.
     *
     */
    function updateThemeForPalette(palette) {
      console.log("MaterialThemeStore ::: updateThemeForPalette");
      console.log(" - palette item: ", palette);
      console.log(" - palette is custom: ", palette.isCustom);

      let scheme = currentScheme.value;
      console.log(" - scheme: ", scheme);

      console.log(" - includeOnColors: ", includeOnColors.value);

      // NOTE: If the palette item is a custom palette (success, info, warning, error),
      //   [*] use the `palette.customHex` value instead of the .hex value,
      //   [*] as the `ThemeColor` needs to repreent the blended (harmonized) color.
      //   [*] If the palette item is not a custom palette, use the `palette.hex` value.
      let hex = palette.isCustom ? palette.customHex : palette.hex;
      let argb = palette.isCustom ? palette.customArgb : palette.argb;
      console.log(" - palette hex: ", hex);
      console.log(" - palette argb: ", argb);

      let tp = TonalPalette.fromInt(argb);
      console.log(" - tp: ", tp);

      // Update the light and dark theme colors for the modified palette item.
      if (palette.name === "neutral") {
        let l1 = scheme.light.find((item) => item.name === "background");
        let d1 = scheme.dark.find((item) => item.name === "background");
        let l2 = scheme.light.find((item) => item.name === "surface");
        let d2 = scheme.dark.find((item) => item.name === "surface");

        // Update the light and dark theme colors for the `background` theme color.
        MaterialTheme.updateThemeColor(l1, argb);
        MaterialTheme.updateThemeColor(d1, argb);

        // Update the light and dark theme colors for the `surface` theme color.
        MaterialTheme.updateThemeColor(l2, argb);
        MaterialTheme.updateThemeColor(d2, argb);
      } else if (palette.name === "neutralVariant") {
        let lightColor = scheme.light.find((item) => item.name === "surfaceVariant");
        let darkColor = scheme.dark.find((item) => item.name === "surfaceVariant");

        MaterialTheme.updateThemeColor(lightColor, argb);
        MaterialTheme.updateThemeColor(darkColor, argb);
      } else {
        let lightColor = scheme.light.find((item) => item.name === palette.name);
        console.log(" - lightColor: ", lightColor);

        let darkColor = scheme.dark.find((item) => item.name === palette.name);
        console.log(" - darkColor: ", darkColor);

        MaterialTheme.updateThemeColor(lightColor, argb);
        MaterialTheme.updateThemeColor(darkColor, argb);
      }
      // INFO: Even though only one palette item is modified,
      //   [-] we'll update (brute force) the entire Vuetify hct theme styles.
      // Update the hct-dark and hct-light theme styles.
      materialStore.value.updateHctThemeStyles(scheme.dark, scheme.light, includeOnColors.value);
    }

    /**
     * Updates the blend status for a custom palette item (Success, Info, Warning, Error)
     * in the `VariantScheme.customPaletteColors` array. The `customPaletteColors` is a template
     * used whenever a new scheme is generated and thus the blend status is maintained across schemes.
     *
     * @param {string} paletteName - The name of the custom palette item for which to save the blend status.
     * @param {boolean} blend - The blend status (true/false) to set for the custom palette item.
     */
    function updateBlendForPalette(paletteName, blend) {
      console.log("MaterialThemeStore ::: updateBlendForPalette");
      console.log(" - palette name: ", paletteName);
      console.log(" - blend: ", blend);
      VariantScheme.setBlendForPalette(paletteName, blend);

      const customPalette = currentScheme.value.custom.find((item) => item.name === paletteName);
      console.log(" - customPalette: ", customPalette);
      const tp = customPalette.tonalPalette;
      console.log(" - custom TonalPalette: ", tp);

      const lightColor = currentScheme.value.light.find((item) => item.name === paletteName);
      const darkColor = currentScheme.value.dark.find((item) => item.name === paletteName);

      console.log(" - lightColor: ", lightColor);
      console.log(" - darkColor: ", darkColor);

      const lightArgb = tp.tone(lightColor.tone);
      const darkArgb = tp.tone(darkColor.tone);
      console.log(" - lightArgb: ", lightArgb);
      console.log(" - darkArgb: ", darkArgb);

      const lightHex = hexFromArgb(lightArgb);
      const darkHex = hexFromArgb(darkArgb);
      console.log(" - lightHex: ", lightHex);
      console.log(" - darkHex: ", darkHex);

      // Update dark and light colors with the new hex color depending on blend status.
      lightColor.hex = lightHex;
      darkColor.hex = darkHex;
    }

    /**
     * Recreates the scheme for the current variant and contrast.
     *
     * Changes made to any of the current scheme palettes will be lost.
     *
     * Triggers an update of the `currentScheme` property, which in turn triggers
     * an update of the Vuetify hct-dark and hct-light theme styles.
     *
     * // FIXME: When the contrast changes, modified PaletteCore and PaletteCustom items
     * // [+] need to be chached and, if possible, reapplied/restored.
     *
     */
    function updateScheme() {
      console.log("MaterialThemeStore ::: updateScheme");
      console.log(" - currentVariant: ", currentVariant.value);
      console.log(" - currentContrast: ", currentContrast.value);
      // Recreate the scheme for the current variant and contrast
      createSchemeForHex(sourceColor.value);
    }

    /**
     * Updates a theme item's color and onTone values, and updates the theme styles in the store.
     *
     * @param {ThemeColor} item - The theme item to be updated.
     *
     * @returns {ThemeColor} The updated theme item.
     */
    function updateThemeItem(item) {
      console.log("MaterialThemeStore ::: updateThemeItem");
      console.log(" - item: ", item);
      const scheme = currentScheme.value;

      const palettes = scheme.palettes;
      const custom = scheme.custom;

      // Find the palette object in the current scheme that matches the theme item
      let paletteColor;
      if (item.isCustom) {
        // If the theme item is a custom palette, use the `custom` palette list.
        paletteColor = custom.find((pc) => pc.name === item.name);
      } else if (item.name === "background" || item.name === "surface") {
        paletteColor = palettes.find((pc) => pc.name === "neutral");
      } else if (item.name === "surfaceVariant") {
        paletteColor = palettes.find((pc) => pc.name === "neutralVariant");
      } else {
        paletteColor = palettes.find((pc) => pc.name === item.name);
      }
      console.log(" - paletteColor: ", paletteColor);

      const bgTone = item.tone;
      console.log(" - original tone: ", bgTone);
      console.log(" - original onTone: ", item.onTone);

      // Note that the theme item's tone (`item.tone`) has already been updated by the slider (v-model).
      // All we need to do now is to get the tonal palette from the palette color and get the argb for the updated tone.
      // Then convert the new tonal argb to hex and update the item's hex.
      // Finally, update the (Vuetify) theme styles in the store.

      if (paletteColor) {
        console.log(" - paletteColor isCustom: ", paletteColor.isCustom);
        let tp = paletteColor.tonalPalette;
        let tpArgb = tp.tone(item.tone);
        let tpHex = hexFromArgb(tpArgb);
        console.log(" - tp: ", tp);
        console.log(" - tpArgb: ", tpArgb);
        console.log(" - tpHex: ", tpHex);
        // Update the item hex with new hex color.
        item.hex = tpHex;
        // Update the theme styles in the store.
        updateThemeStyles();
      }
    }

    /**
     * Creates a scheme for the given hex color and stores it in the `currentScheme` property.
     *
     * The `dark` and `light` theme colors are then used to update the `hct-dark` and `hct-light` theme styles.
     *
     * @param {string} color - The hex color to create a scheme for.
     */
    function createSchemeForHex(color) {
      console.log("MaterialThemeStore ::: createSchemeForHex");
      sourceColor.value = color;
      const argb = argbFromHex(color);
      const variant = currentVariant.value;
      const contrast = currentContrast.value;

      // Create the scheme for the current source, variant and contrast.
      const varScheme = VariantScheme.createScheme(argb, variant, contrast);
      currentScheme.value = varScheme;

      // (Re)apply theme card (UI) expanded state.
      toggleAllThemeCards();

      // Update the light and dark theme colors for the hct-dark and hct-light theme.
      materialStore.value.updateHctThemeStyles(varScheme.dark, varScheme.light, includeOnColors.value);
    }

    return {
      sourceColor,
      currentVariant,
      currentContrast,
      currentScheme,
      includeOnColors,
      showImageCards,
      showVariantInfo,
      showPaletteCards,
      expandThemeCards,
      showDarkThemeCard,
      showLightThemeCard,
      schemeVariants,
      favoriteColors,
      toggleAllThemeCards,
      setCurrentVariant,
      updateThemeStyles,
      updateThemeForPalette,
      updateBlendForPalette,
      updateThemeItem,
      updateScheme,
      createSchemeForHex
    };
  },
  { persist: true }
);
