import { argbFromHex, hexFromArgb, Hct, TonalPalette, DynamicColor, Contrast } from "@material/material-color-utilities";

/**
 * Creates a new ThemeColor object.
 *
 * @param {string} [title] - The title of the theme color.
 * @param {string} [name] - The name of the theme color. Will be used as the key in the theme object.
 * @param {TonalPalette} [tonalPalette] - The `TonalPalette` representation - as generated by the `DynamicScheme` - of the ThemeColor.
 * @param {number} [tone] - The initial tone value of the theme color.
 * @param {boolean} [isDark=false] - Whether the theme color is dark. The default value is `false`.
 * @param {boolean} [isCustom=false] - Whether the theme color is a custom color. The default value is `false` and is read only.
 */
export default class ThemeColor {
  constructor(title, name, tonalPalette, tone, isDark, isCustom = false) {
    this.title = title;
    Object.defineProperty(this, "name", { value: name, enumerable: true });
    this.tonalPalette = tonalPalette;
    this.tone = tone;
    Object.defineProperty(this, "initialTone", { value: tone });
    Object.defineProperty(this, "isDark", { value: isDark });
    Object.defineProperty(this, "isCustom", { value: isCustom });

    this.toggle = false;
  }

  get hex() {
    // console.log("ThemeColor ::: hex");
    return hexFromArgb(this.argb);
  }

  /**
   * The ARGB representation of the hex color.
   * @type {number}
   */
  get argb() {
    return this.tonalPalette.tone(this.tone);
  }

  /**
   * The HCT representation of the hex color.
   * @type {Hct}
   */
  get hct() {
    return Hct.fromInt(this.argb);
  }

  /**
   * The tone value of the "on" color for this `ThemeColor`.
   *
   * Uses the `DynamicColor.foregroundTone()` method to compute the tone value of the "on" color.
   * @type {number} The tone value of the "on" color.
   */
  get onTone() {
    // console.log("ThemeColor ::: onTone");
    // console.log(" - this.name: ", this.name);

    // const measuredRatio10 = Contrast.ratioOfTones(this.tone, 5);
    // console.log(" - measured contrast ratio - tone -> 5: ", measuredRatio10);
    // const measuredRatio90 = Contrast.ratioOfTones(this.tone, 95);
    // console.log(" - measured contrast ratio - tone -> 95: ", measuredRatio90);

    // Not happy with result of foregroundTone.
    // let fgTone = Math.round(DynamicColor.foregroundTone(this.tone, ratio));
    let fgTone = ThemeColor.getForegroundTone(this.tone);
    return fgTone;
  }

  /**
   * Computes the hex color for the "on" color for this `ThemeColor`.
   *
   * The method uses the onTone value to determine the tone of the "on" color.
   * @type {string} The hex representation of the "on" color.
   */
  get onHex() {
    const tp = this.tonalPalette;
    const onArgb = tp.tone(this.onTone);
    const hex = hexFromArgb(onArgb);
    return hex;
  }

  /**
   * The label of the color.
   *
   * The label is in the format `"{prefix}-{tone}"`, where `{prefix}` indicates the Palette
   * the color is derived from (e.g. "P" for primary, "S" for secondary, "N" for neutral etc.),
   * and `{tone}` is the tone amount used on the Palette to achieve the theme color (e.g. "30", "60", etc.).
   *
   * So for example a theme color with label `"P-30"` means that the theme color is derived from the `primary` Palette with a tone of 30 applied to it.
   * Some theme colors are not derived from a Palette with the same name.
   * For example, the `background` and `surface` theme colors are both derived from the `neutral` Palette.
   * So the label of the background theme color looks like: "N-10".
   *
   * @type {string}
   */
  get label() {
    return ThemeColor.getLabelPrefix(this.name) + "-" + this.tone.toString();
  }

  /**
   * Resets the tone of the ThemeColor to its initial tone value.
   *
   * This method updates the `tone` property of the ThemeColor instance
   * to match the `initialTone` value, effectively reverting any changes
   * made to the tone since the ThemeColor was instantiated.
   *
   */
  resetTone() {
    console.log("ThemeColor ::: resetTone");
    this.tone = this.initialTone;
  }
}

ThemeColor.ratio = 7.5;

ThemeColor.getLabelPrefix = function (name) {
  switch (name) {
    case "primary":
      return "P";
    case "secondary":
      return "S";
    case "tertiary":
      return "T";
    case "success":
      return "CS";
    case "info":
      return "CI";
    case "warning":
      return "CW";
    case "error":
      return "CE";
    case "background":
    case "surface":
      return "N";
    case "surfaceVariant":
      return "NV";
    default:
      return "";
  }
};

/**
 * Computes the foreground tone of a theme color given its tone and the desired contrast ratio.
 *
 * Material Utilities has a method called `DynamicColor.foregroundTone()` which theoretically does the same thing.
 * However, it does not respoect the rule that a dark foreground tone shouldn't be used below 60 tone.
 *
 * @example const foregroundTone = DynamicColor.foregroundTone(bgTone, ratio);
 *
 * So since we're not happy with the result of `DynamicColor.foregroundTone()`, we've implemented our own method.
 *
 * @param {number} tone - The tone of the theme color.
 * @returns {number} The foreground tone (rounded off) of the theme color.
 */
ThemeColor.getForegroundTone = function (tone) {
  // Contrast value is defined by tone, regardless of color.
  // Since the theme item's tone just changed, we need to determine the onTone value.

  const ratio = ThemeColor.ratio;
  const bgTone = tone;

  // Measured ratio (Contrast.ratioOfTones()) can only be measured when an onTone value is available.
  // This could however be used to determine which generated onTone's ratio is closest to the desired ratio.

  // Get the darker contrasting tone. Returns -1 if contrast ratio can not be met.
  const darker = Contrast.darker(bgTone, ratio);
  // Get the lighter contrasting tone. Returns -1 if contrast ratio can not be met.
  const lighter = Contrast.lighter(bgTone, ratio);

  const contrastTone = Math.max(Math.round(darker), Math.round(lighter));

  // If the contrast ratio can not be met (lighter and darker are -1), use the unsafe version.
  const darkerUnsafe = Contrast.darkerUnsafe(bgTone, ratio);
  const lighterUnsafe = Contrast.lighterUnsafe(bgTone, ratio);

  // Get the highest unsafe contrast tone.
  const contrastToneUnsafe = Math.max(Math.round(darkerUnsafe), Math.round(lighterUnsafe));

  // Check if safe tone is -1, if not, use it, otherwise use the unsafe tone.
  const onTone = contrastTone !== -1 ? contrastTone : contrastToneUnsafe;

  return onTone;
};
